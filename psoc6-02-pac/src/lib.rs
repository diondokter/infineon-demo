#![doc = "Peripheral access API for PSOC6_02 microcontrollers (generated using svd2rust v0.33.4 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.33.4/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![no_std]
use core::marker::PhantomData;
use core::ops::Deref;
#[doc = r"Number available in the NVIC for configuring priority"]
pub const NVIC_PRIO_BITS: u8 = 3;
#[allow(unused_imports)]
use generic::*;
#[doc = r"Common register and bit access and modify traits"]
pub mod generic;
#[cfg(feature = "rt")]
extern "C" {
    fn ioss_interrupts_gpio_0();
    fn ioss_interrupts_gpio_1();
    fn ioss_interrupts_gpio_2();
    fn ioss_interrupts_gpio_3();
    fn ioss_interrupts_gpio_4();
    fn ioss_interrupts_gpio_5();
    fn ioss_interrupts_gpio_6();
    fn ioss_interrupts_gpio_7();
    fn ioss_interrupts_gpio_8();
    fn ioss_interrupts_gpio_9();
    fn ioss_interrupts_gpio_10();
    fn ioss_interrupts_gpio_11();
    fn ioss_interrupts_gpio_12();
    fn ioss_interrupts_gpio_13();
    fn ioss_interrupts_gpio_14();
    fn ioss_interrupt_gpio();
    fn ioss_interrupt_vdd();
    fn lpcomp_interrupt();
    fn scb_8_interrupt();
    fn srss_interrupt_mcwdt_0();
    fn srss_interrupt_mcwdt_1();
    fn srss_interrupt_backup();
    fn srss_interrupt();
    fn cpuss_interrupts_ipc_0();
    fn cpuss_interrupts_ipc_1();
    fn cpuss_interrupts_ipc_2();
    fn cpuss_interrupts_ipc_3();
    fn cpuss_interrupts_ipc_4();
    fn cpuss_interrupts_ipc_5();
    fn cpuss_interrupts_ipc_6();
    fn cpuss_interrupts_ipc_7();
    fn cpuss_interrupts_ipc_8();
    // fn cpuss_interrupts_ipc_9();
    // fn cpuss_interrupts_ipc_10();
    // fn cpuss_interrupts_ipc_11();
    // fn cpuss_interrupts_ipc_12();
    // fn cpuss_interrupts_ipc_13();
    // fn cpuss_interrupts_ipc_14();
    // fn cpuss_interrupts_ipc_15();
    // fn scb_0_interrupt();
    // fn scb_1_interrupt();
    // fn scb_2_interrupt();
    // fn scb_3_interrupt();
    // fn scb_4_interrupt();
    // fn scb_5_interrupt();
    // fn scb_6_interrupt();
    // fn scb_7_interrupt();
    // fn scb_9_interrupt();
    // fn scb_10_interrupt();
    // fn scb_11_interrupt();
    // fn scb_12_interrupt();
    // fn csd_interrupt();
    // fn cpuss_interrupts_dmac_0();
    // fn cpuss_interrupts_dmac_1();
    // fn cpuss_interrupts_dmac_2();
    // fn cpuss_interrupts_dmac_3();
    // fn cpuss_interrupts_dw0_0();
    // fn cpuss_interrupts_dw0_1();
    // fn cpuss_interrupts_dw0_2();
    // fn cpuss_interrupts_dw0_3();
    // fn cpuss_interrupts_dw0_4();
    // fn cpuss_interrupts_dw0_5();
    // fn cpuss_interrupts_dw0_6();
    // fn cpuss_interrupts_dw0_7();
    // fn cpuss_interrupts_dw0_8();
    // fn cpuss_interrupts_dw0_9();
    // fn cpuss_interrupts_dw0_10();
    // fn cpuss_interrupts_dw0_11();
    // fn cpuss_interrupts_dw0_12();
    // fn cpuss_interrupts_dw0_13();
    // fn cpuss_interrupts_dw0_14();
    // fn cpuss_interrupts_dw0_15();
    // fn cpuss_interrupts_dw0_16();
    // fn cpuss_interrupts_dw0_17();
    // fn cpuss_interrupts_dw0_18();
    // fn cpuss_interrupts_dw0_19();
    // fn cpuss_interrupts_dw0_20();
    // fn cpuss_interrupts_dw0_21();
    // fn cpuss_interrupts_dw0_22();
    // fn cpuss_interrupts_dw0_23();
    // fn cpuss_interrupts_dw0_24();
    // fn cpuss_interrupts_dw0_25();
    // fn cpuss_interrupts_dw0_26();
    // fn cpuss_interrupts_dw0_27();
    // fn cpuss_interrupts_dw0_28();
    // fn cpuss_interrupts_dw1_0();
    // fn cpuss_interrupts_dw1_1();
    // fn cpuss_interrupts_dw1_2();
    // fn cpuss_interrupts_dw1_3();
    // fn cpuss_interrupts_dw1_4();
    // fn cpuss_interrupts_dw1_5();
    // fn cpuss_interrupts_dw1_6();
    // fn cpuss_interrupts_dw1_7();
    // fn cpuss_interrupts_dw1_8();
    // fn cpuss_interrupts_dw1_9();
    // fn cpuss_interrupts_dw1_10();
    // fn cpuss_interrupts_dw1_11();
    // fn cpuss_interrupts_dw1_12();
    // fn cpuss_interrupts_dw1_13();
    // fn cpuss_interrupts_dw1_14();
    // fn cpuss_interrupts_dw1_15();
    // fn cpuss_interrupts_dw1_16();
    // fn cpuss_interrupts_dw1_17();
    // fn cpuss_interrupts_dw1_18();
    // fn cpuss_interrupts_dw1_19();
    // fn cpuss_interrupts_dw1_20();
    // fn cpuss_interrupts_dw1_21();
    // fn cpuss_interrupts_dw1_22();
    // fn cpuss_interrupts_dw1_23();
    // fn cpuss_interrupts_dw1_24();
    // fn cpuss_interrupts_dw1_25();
    // fn cpuss_interrupts_dw1_26();
    // fn cpuss_interrupts_dw1_27();
    // fn cpuss_interrupts_dw1_28();
    // fn cpuss_interrupts_fault_0();
    // fn cpuss_interrupts_fault_1();
    // fn cpuss_interrupt_crypto();
    // fn cpuss_interrupt_fm();
    // fn cpuss_interrupts_cm4_fp();
    // fn cpuss_interrupts_cm0_cti_0();
    // fn cpuss_interrupts_cm0_cti_1();
    // fn cpuss_interrupts_cm4_cti_0();
    // fn cpuss_interrupts_cm4_cti_1();
    // fn tcpwm_0_interrupts_0();
    // fn tcpwm_0_interrupts_1();
    // fn tcpwm_0_interrupts_2();
    // fn tcpwm_0_interrupts_3();
    // fn tcpwm_0_interrupts_4();
    // fn tcpwm_0_interrupts_5();
    // fn tcpwm_0_interrupts_6();
    // fn tcpwm_0_interrupts_7();
    // fn tcpwm_1_interrupts_0();
    // fn tcpwm_1_interrupts_1();
    // fn tcpwm_1_interrupts_2();
    // fn tcpwm_1_interrupts_3();
    // fn tcpwm_1_interrupts_4();
    // fn tcpwm_1_interrupts_5();
    // fn tcpwm_1_interrupts_6();
    // fn tcpwm_1_interrupts_7();
    // fn tcpwm_1_interrupts_8();
    // fn tcpwm_1_interrupts_9();
    // fn tcpwm_1_interrupts_10();
    // fn tcpwm_1_interrupts_11();
    // fn tcpwm_1_interrupts_12();
    // fn tcpwm_1_interrupts_13();
    // fn tcpwm_1_interrupts_14();
    // fn tcpwm_1_interrupts_15();
    // fn tcpwm_1_interrupts_16();
    // fn tcpwm_1_interrupts_17();
    // fn tcpwm_1_interrupts_18();
    // fn tcpwm_1_interrupts_19();
    // fn tcpwm_1_interrupts_20();
    // fn tcpwm_1_interrupts_21();
    // fn tcpwm_1_interrupts_22();
    // fn tcpwm_1_interrupts_23();
    // fn pass_interrupt_sar();
    // fn audioss_0_interrupt_i2s();
    // fn audioss_0_interrupt_pdm();
    // fn audioss_1_interrupt_i2s();
    // fn profile_interrupt();
    // fn smif_interrupt();
    // fn usb_interrupt_hi();
    // fn usb_interrupt_med();
    // fn usb_interrupt_lo();
    // fn sdhc_0_interrupt_wakeup();
    // fn sdhc_0_interrupt_general();
    // fn sdhc_1_interrupt_wakeup();
    // fn sdhc_1_interrupt_general();
}
#[doc(hidden)]
#[repr(C)]
pub union Vector {
    _handler: unsafe extern "C" fn(),
    _reserved: u32,
}
#[cfg(feature = "rt")]
#[doc(hidden)]
#[link_section = ".vector_table.interrupts"]
#[no_mangle]
pub static __INTERRUPTS: [Vector; 32] = [
    Vector {
        _handler: ioss_interrupts_gpio_0,
    },
    Vector {
        _handler: ioss_interrupts_gpio_1,
    },
    Vector {
        _handler: ioss_interrupts_gpio_2,
    },
    Vector {
        _handler: ioss_interrupts_gpio_3,
    },
    Vector {
        _handler: ioss_interrupts_gpio_4,
    },
    Vector {
        _handler: ioss_interrupts_gpio_5,
    },
    Vector {
        _handler: ioss_interrupts_gpio_6,
    },
    Vector {
        _handler: ioss_interrupts_gpio_7,
    },
    Vector {
        _handler: ioss_interrupts_gpio_8,
    },
    Vector {
        _handler: ioss_interrupts_gpio_9,
    },
    Vector {
        _handler: ioss_interrupts_gpio_10,
    },
    Vector {
        _handler: ioss_interrupts_gpio_11,
    },
    Vector {
        _handler: ioss_interrupts_gpio_12,
    },
    Vector {
        _handler: ioss_interrupts_gpio_13,
    },
    Vector {
        _handler: ioss_interrupts_gpio_14,
    },
    Vector {
        _handler: ioss_interrupt_gpio,
    },
    Vector {
        _handler: ioss_interrupt_vdd,
    },
    Vector {
        _handler: lpcomp_interrupt,
    },
    Vector {
        _handler: scb_8_interrupt,
    },
    Vector {
        _handler: srss_interrupt_mcwdt_0,
    },
    Vector {
        _handler: srss_interrupt_mcwdt_1,
    },
    Vector {
        _handler: srss_interrupt_backup,
    },
    Vector {
        _handler: srss_interrupt,
    },
    Vector {
        _handler: cpuss_interrupts_ipc_0,
    },
    Vector {
        _handler: cpuss_interrupts_ipc_1,
    },
    Vector {
        _handler: cpuss_interrupts_ipc_2,
    },
    Vector {
        _handler: cpuss_interrupts_ipc_3,
    },
    Vector {
        _handler: cpuss_interrupts_ipc_4,
    },
    Vector {
        _handler: cpuss_interrupts_ipc_5,
    },
    Vector {
        _handler: cpuss_interrupts_ipc_6,
    },
    Vector {
        _handler: cpuss_interrupts_ipc_7,
    },
    Vector {
        _handler: cpuss_interrupts_ipc_8,
    },
    // Vector {
    //     _handler: cpuss_interrupts_ipc_9,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_ipc_10,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_ipc_11,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_ipc_12,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_ipc_13,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_ipc_14,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_ipc_15,
    // },
    // Vector {
    //     _handler: scb_0_interrupt,
    // },
    // Vector {
    //     _handler: scb_1_interrupt,
    // },
    // Vector {
    //     _handler: scb_2_interrupt,
    // },
    // Vector {
    //     _handler: scb_3_interrupt,
    // },
    // Vector {
    //     _handler: scb_4_interrupt,
    // },
    // Vector {
    //     _handler: scb_5_interrupt,
    // },
    // Vector {
    //     _handler: scb_6_interrupt,
    // },
    // Vector {
    //     _handler: scb_7_interrupt,
    // },
    // Vector {
    //     _handler: scb_9_interrupt,
    // },
    // Vector {
    //     _handler: scb_10_interrupt,
    // },
    // Vector {
    //     _handler: scb_11_interrupt,
    // },
    // Vector {
    //     _handler: scb_12_interrupt,
    // },
    // Vector {
    //     _handler: csd_interrupt,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dmac_0,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dmac_1,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dmac_2,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dmac_3,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_0,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_1,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_2,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_3,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_4,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_5,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_6,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_7,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_8,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_9,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_10,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_11,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_12,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_13,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_14,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_15,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_16,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_17,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_18,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_19,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_20,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_21,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_22,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_23,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_24,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_25,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_26,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_27,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw0_28,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_0,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_1,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_2,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_3,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_4,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_5,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_6,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_7,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_8,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_9,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_10,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_11,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_12,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_13,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_14,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_15,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_16,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_17,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_18,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_19,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_20,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_21,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_22,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_23,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_24,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_25,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_26,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_27,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_dw1_28,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_fault_0,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_fault_1,
    // },
    // Vector {
    //     _handler: cpuss_interrupt_crypto,
    // },
    // Vector {
    //     _handler: cpuss_interrupt_fm,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_cm4_fp,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_cm0_cti_0,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_cm0_cti_1,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_cm4_cti_0,
    // },
    // Vector {
    //     _handler: cpuss_interrupts_cm4_cti_1,
    // },
    // Vector {
    //     _handler: tcpwm_0_interrupts_0,
    // },
    // Vector {
    //     _handler: tcpwm_0_interrupts_1,
    // },
    // Vector {
    //     _handler: tcpwm_0_interrupts_2,
    // },
    // Vector {
    //     _handler: tcpwm_0_interrupts_3,
    // },
    // Vector {
    //     _handler: tcpwm_0_interrupts_4,
    // },
    // Vector {
    //     _handler: tcpwm_0_interrupts_5,
    // },
    // Vector {
    //     _handler: tcpwm_0_interrupts_6,
    // },
    // Vector {
    //     _handler: tcpwm_0_interrupts_7,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_0,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_1,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_2,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_3,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_4,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_5,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_6,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_7,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_8,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_9,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_10,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_11,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_12,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_13,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_14,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_15,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_16,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_17,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_18,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_19,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_20,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_21,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_22,
    // },
    // Vector {
    //     _handler: tcpwm_1_interrupts_23,
    // },
    // Vector {
    //     _handler: pass_interrupt_sar,
    // },
    // Vector {
    //     _handler: audioss_0_interrupt_i2s,
    // },
    // Vector {
    //     _handler: audioss_0_interrupt_pdm,
    // },
    // Vector {
    //     _handler: audioss_1_interrupt_i2s,
    // },
    // Vector {
    //     _handler: profile_interrupt,
    // },
    // Vector {
    //     _handler: smif_interrupt,
    // },
    // Vector {
    //     _handler: usb_interrupt_hi,
    // },
    // Vector {
    //     _handler: usb_interrupt_med,
    // },
    // Vector {
    //     _handler: usb_interrupt_lo,
    // },
    // Vector {
    //     _handler: sdhc_0_interrupt_wakeup,
    // },
    // Vector {
    //     _handler: sdhc_0_interrupt_general,
    // },
    // Vector {
    //     _handler: sdhc_1_interrupt_wakeup,
    // },
    // Vector {
    //     _handler: sdhc_1_interrupt_general,
    // },
];
#[doc = r"Enumeration of all the interrupts."]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
#[repr(u16)]
pub enum Interrupt {
    #[doc = "0 - GPIO Port Interrupt #0"]
    ioss_interrupts_gpio_0 = 0,
    #[doc = "1 - GPIO Port Interrupt #1"]
    ioss_interrupts_gpio_1 = 1,
    #[doc = "2 - GPIO Port Interrupt #2"]
    ioss_interrupts_gpio_2 = 2,
    #[doc = "3 - GPIO Port Interrupt #3"]
    ioss_interrupts_gpio_3 = 3,
    #[doc = "4 - GPIO Port Interrupt #4"]
    ioss_interrupts_gpio_4 = 4,
    #[doc = "5 - GPIO Port Interrupt #5"]
    ioss_interrupts_gpio_5 = 5,
    #[doc = "6 - GPIO Port Interrupt #6"]
    ioss_interrupts_gpio_6 = 6,
    #[doc = "7 - GPIO Port Interrupt #7"]
    ioss_interrupts_gpio_7 = 7,
    #[doc = "8 - GPIO Port Interrupt #8"]
    ioss_interrupts_gpio_8 = 8,
    #[doc = "9 - GPIO Port Interrupt #9"]
    ioss_interrupts_gpio_9 = 9,
    #[doc = "10 - GPIO Port Interrupt #10"]
    ioss_interrupts_gpio_10 = 10,
    #[doc = "11 - GPIO Port Interrupt #11"]
    ioss_interrupts_gpio_11 = 11,
    #[doc = "12 - GPIO Port Interrupt #12"]
    ioss_interrupts_gpio_12 = 12,
    #[doc = "13 - GPIO Port Interrupt #13"]
    ioss_interrupts_gpio_13 = 13,
    #[doc = "14 - GPIO Port Interrupt #14"]
    ioss_interrupts_gpio_14 = 14,
    #[doc = "15 - GPIO All Ports"]
    ioss_interrupt_gpio = 15,
    #[doc = "16 - GPIO Supply Detect Interrupt"]
    ioss_interrupt_vdd = 16,
    #[doc = "17 - Low Power Comparator Interrupt"]
    lpcomp_interrupt = 17,
    #[doc = "18 - Serial Communication Block #8 (DeepSleep capable)"]
    scb_8_interrupt = 18,
    #[doc = "19 - Multi Counter Watchdog Timer interrupt"]
    srss_interrupt_mcwdt_0 = 19,
    #[doc = "20 - Multi Counter Watchdog Timer interrupt"]
    srss_interrupt_mcwdt_1 = 20,
    #[doc = "21 - Backup domain interrupt"]
    srss_interrupt_backup = 21,
    #[doc = "22 - Other combined Interrupts for SRSS (LVD, WDT, CLKCAL)"]
    srss_interrupt = 22,
    #[doc = "23 - CPUSS Inter Process Communication Interrupt #0"]
    cpuss_interrupts_ipc_0 = 23,
    #[doc = "24 - CPUSS Inter Process Communication Interrupt #1"]
    cpuss_interrupts_ipc_1 = 24,
    #[doc = "25 - CPUSS Inter Process Communication Interrupt #2"]
    cpuss_interrupts_ipc_2 = 25,
    #[doc = "26 - CPUSS Inter Process Communication Interrupt #3"]
    cpuss_interrupts_ipc_3 = 26,
    #[doc = "27 - CPUSS Inter Process Communication Interrupt #4"]
    cpuss_interrupts_ipc_4 = 27,
    #[doc = "28 - CPUSS Inter Process Communication Interrupt #5"]
    cpuss_interrupts_ipc_5 = 28,
    #[doc = "29 - CPUSS Inter Process Communication Interrupt #6"]
    cpuss_interrupts_ipc_6 = 29,
    #[doc = "30 - CPUSS Inter Process Communication Interrupt #7"]
    cpuss_interrupts_ipc_7 = 30,
    #[doc = "31 - CPUSS Inter Process Communication Interrupt #8"]
    cpuss_interrupts_ipc_8 = 31,
    #[doc = "32 - CPUSS Inter Process Communication Interrupt #9"]
    cpuss_interrupts_ipc_9 = 32,
    #[doc = "33 - CPUSS Inter Process Communication Interrupt #10"]
    cpuss_interrupts_ipc_10 = 33,
    #[doc = "34 - CPUSS Inter Process Communication Interrupt #11"]
    cpuss_interrupts_ipc_11 = 34,
    #[doc = "35 - CPUSS Inter Process Communication Interrupt #12"]
    cpuss_interrupts_ipc_12 = 35,
    #[doc = "36 - CPUSS Inter Process Communication Interrupt #13"]
    cpuss_interrupts_ipc_13 = 36,
    #[doc = "37 - CPUSS Inter Process Communication Interrupt #14"]
    cpuss_interrupts_ipc_14 = 37,
    #[doc = "38 - CPUSS Inter Process Communication Interrupt #15"]
    cpuss_interrupts_ipc_15 = 38,
    #[doc = "39 - Serial Communication Block #0"]
    scb_0_interrupt = 39,
    #[doc = "40 - Serial Communication Block #1"]
    scb_1_interrupt = 40,
    #[doc = "41 - Serial Communication Block #2"]
    scb_2_interrupt = 41,
    #[doc = "42 - Serial Communication Block #3"]
    scb_3_interrupt = 42,
    #[doc = "43 - Serial Communication Block #4"]
    scb_4_interrupt = 43,
    #[doc = "44 - Serial Communication Block #5"]
    scb_5_interrupt = 44,
    #[doc = "45 - Serial Communication Block #6"]
    scb_6_interrupt = 45,
    #[doc = "46 - Serial Communication Block #7"]
    scb_7_interrupt = 46,
    #[doc = "47 - Serial Communication Block #9"]
    scb_9_interrupt = 47,
    #[doc = "48 - Serial Communication Block #10"]
    scb_10_interrupt = 48,
    #[doc = "49 - Serial Communication Block #11"]
    scb_11_interrupt = 49,
    #[doc = "50 - Serial Communication Block #12"]
    scb_12_interrupt = 50,
    #[doc = "51 - CSD (Capsense) interrupt"]
    csd_interrupt = 51,
    #[doc = "52 - CPUSS DMAC, Channel #0"]
    cpuss_interrupts_dmac_0 = 52,
    #[doc = "53 - CPUSS DMAC, Channel #1"]
    cpuss_interrupts_dmac_1 = 53,
    #[doc = "54 - CPUSS DMAC, Channel #2"]
    cpuss_interrupts_dmac_2 = 54,
    #[doc = "55 - CPUSS DMAC, Channel #3"]
    cpuss_interrupts_dmac_3 = 55,
    #[doc = "56 - CPUSS DataWire #0, Channel #0"]
    cpuss_interrupts_dw0_0 = 56,
    #[doc = "57 - CPUSS DataWire #0, Channel #1"]
    cpuss_interrupts_dw0_1 = 57,
    #[doc = "58 - CPUSS DataWire #0, Channel #2"]
    cpuss_interrupts_dw0_2 = 58,
    #[doc = "59 - CPUSS DataWire #0, Channel #3"]
    cpuss_interrupts_dw0_3 = 59,
    #[doc = "60 - CPUSS DataWire #0, Channel #4"]
    cpuss_interrupts_dw0_4 = 60,
    #[doc = "61 - CPUSS DataWire #0, Channel #5"]
    cpuss_interrupts_dw0_5 = 61,
    #[doc = "62 - CPUSS DataWire #0, Channel #6"]
    cpuss_interrupts_dw0_6 = 62,
    #[doc = "63 - CPUSS DataWire #0, Channel #7"]
    cpuss_interrupts_dw0_7 = 63,
    #[doc = "64 - CPUSS DataWire #0, Channel #8"]
    cpuss_interrupts_dw0_8 = 64,
    #[doc = "65 - CPUSS DataWire #0, Channel #9"]
    cpuss_interrupts_dw0_9 = 65,
    #[doc = "66 - CPUSS DataWire #0, Channel #10"]
    cpuss_interrupts_dw0_10 = 66,
    #[doc = "67 - CPUSS DataWire #0, Channel #11"]
    cpuss_interrupts_dw0_11 = 67,
    #[doc = "68 - CPUSS DataWire #0, Channel #12"]
    cpuss_interrupts_dw0_12 = 68,
    #[doc = "69 - CPUSS DataWire #0, Channel #13"]
    cpuss_interrupts_dw0_13 = 69,
    #[doc = "70 - CPUSS DataWire #0, Channel #14"]
    cpuss_interrupts_dw0_14 = 70,
    #[doc = "71 - CPUSS DataWire #0, Channel #15"]
    cpuss_interrupts_dw0_15 = 71,
    #[doc = "72 - CPUSS DataWire #0, Channel #16"]
    cpuss_interrupts_dw0_16 = 72,
    #[doc = "73 - CPUSS DataWire #0, Channel #17"]
    cpuss_interrupts_dw0_17 = 73,
    #[doc = "74 - CPUSS DataWire #0, Channel #18"]
    cpuss_interrupts_dw0_18 = 74,
    #[doc = "75 - CPUSS DataWire #0, Channel #19"]
    cpuss_interrupts_dw0_19 = 75,
    #[doc = "76 - CPUSS DataWire #0, Channel #20"]
    cpuss_interrupts_dw0_20 = 76,
    #[doc = "77 - CPUSS DataWire #0, Channel #21"]
    cpuss_interrupts_dw0_21 = 77,
    #[doc = "78 - CPUSS DataWire #0, Channel #22"]
    cpuss_interrupts_dw0_22 = 78,
    #[doc = "79 - CPUSS DataWire #0, Channel #23"]
    cpuss_interrupts_dw0_23 = 79,
    #[doc = "80 - CPUSS DataWire #0, Channel #24"]
    cpuss_interrupts_dw0_24 = 80,
    #[doc = "81 - CPUSS DataWire #0, Channel #25"]
    cpuss_interrupts_dw0_25 = 81,
    #[doc = "82 - CPUSS DataWire #0, Channel #26"]
    cpuss_interrupts_dw0_26 = 82,
    #[doc = "83 - CPUSS DataWire #0, Channel #27"]
    cpuss_interrupts_dw0_27 = 83,
    #[doc = "84 - CPUSS DataWire #0, Channel #28"]
    cpuss_interrupts_dw0_28 = 84,
    #[doc = "85 - CPUSS DataWire #1, Channel #0"]
    cpuss_interrupts_dw1_0 = 85,
    #[doc = "86 - CPUSS DataWire #1, Channel #1"]
    cpuss_interrupts_dw1_1 = 86,
    #[doc = "87 - CPUSS DataWire #1, Channel #2"]
    cpuss_interrupts_dw1_2 = 87,
    #[doc = "88 - CPUSS DataWire #1, Channel #3"]
    cpuss_interrupts_dw1_3 = 88,
    #[doc = "89 - CPUSS DataWire #1, Channel #4"]
    cpuss_interrupts_dw1_4 = 89,
    #[doc = "90 - CPUSS DataWire #1, Channel #5"]
    cpuss_interrupts_dw1_5 = 90,
    #[doc = "91 - CPUSS DataWire #1, Channel #6"]
    cpuss_interrupts_dw1_6 = 91,
    #[doc = "92 - CPUSS DataWire #1, Channel #7"]
    cpuss_interrupts_dw1_7 = 92,
    #[doc = "93 - CPUSS DataWire #1, Channel #8"]
    cpuss_interrupts_dw1_8 = 93,
    #[doc = "94 - CPUSS DataWire #1, Channel #9"]
    cpuss_interrupts_dw1_9 = 94,
    #[doc = "95 - CPUSS DataWire #1, Channel #10"]
    cpuss_interrupts_dw1_10 = 95,
    #[doc = "96 - CPUSS DataWire #1, Channel #11"]
    cpuss_interrupts_dw1_11 = 96,
    #[doc = "97 - CPUSS DataWire #1, Channel #12"]
    cpuss_interrupts_dw1_12 = 97,
    #[doc = "98 - CPUSS DataWire #1, Channel #13"]
    cpuss_interrupts_dw1_13 = 98,
    #[doc = "99 - CPUSS DataWire #1, Channel #14"]
    cpuss_interrupts_dw1_14 = 99,
    #[doc = "100 - CPUSS DataWire #1, Channel #15"]
    cpuss_interrupts_dw1_15 = 100,
    #[doc = "101 - CPUSS DataWire #1, Channel #16"]
    cpuss_interrupts_dw1_16 = 101,
    #[doc = "102 - CPUSS DataWire #1, Channel #17"]
    cpuss_interrupts_dw1_17 = 102,
    #[doc = "103 - CPUSS DataWire #1, Channel #18"]
    cpuss_interrupts_dw1_18 = 103,
    #[doc = "104 - CPUSS DataWire #1, Channel #19"]
    cpuss_interrupts_dw1_19 = 104,
    #[doc = "105 - CPUSS DataWire #1, Channel #20"]
    cpuss_interrupts_dw1_20 = 105,
    #[doc = "106 - CPUSS DataWire #1, Channel #21"]
    cpuss_interrupts_dw1_21 = 106,
    #[doc = "107 - CPUSS DataWire #1, Channel #22"]
    cpuss_interrupts_dw1_22 = 107,
    #[doc = "108 - CPUSS DataWire #1, Channel #23"]
    cpuss_interrupts_dw1_23 = 108,
    #[doc = "109 - CPUSS DataWire #1, Channel #24"]
    cpuss_interrupts_dw1_24 = 109,
    #[doc = "110 - CPUSS DataWire #1, Channel #25"]
    cpuss_interrupts_dw1_25 = 110,
    #[doc = "111 - CPUSS DataWire #1, Channel #26"]
    cpuss_interrupts_dw1_26 = 111,
    #[doc = "112 - CPUSS DataWire #1, Channel #27"]
    cpuss_interrupts_dw1_27 = 112,
    #[doc = "113 - CPUSS DataWire #1, Channel #28"]
    cpuss_interrupts_dw1_28 = 113,
    #[doc = "114 - CPUSS Fault Structure Interrupt #0"]
    cpuss_interrupts_fault_0 = 114,
    #[doc = "115 - CPUSS Fault Structure Interrupt #1"]
    cpuss_interrupts_fault_1 = 115,
    #[doc = "116 - CRYPTO Accelerator Interrupt"]
    cpuss_interrupt_crypto = 116,
    #[doc = "117 - FLASH Macro Interrupt"]
    cpuss_interrupt_fm = 117,
    #[doc = "118 - Floating Point operation fault"]
    cpuss_interrupts_cm4_fp = 118,
    #[doc = "119 - CM0+ CTI #0"]
    cpuss_interrupts_cm0_cti_0 = 119,
    #[doc = "120 - CM0+ CTI #1"]
    cpuss_interrupts_cm0_cti_1 = 120,
    #[doc = "121 - CM4 CTI #0"]
    cpuss_interrupts_cm4_cti_0 = 121,
    #[doc = "122 - CM4 CTI #1"]
    cpuss_interrupts_cm4_cti_1 = 122,
    #[doc = "123 - TCPWM #0, Counter #0"]
    tcpwm_0_interrupts_0 = 123,
    #[doc = "124 - TCPWM #0, Counter #1"]
    tcpwm_0_interrupts_1 = 124,
    #[doc = "125 - TCPWM #0, Counter #2"]
    tcpwm_0_interrupts_2 = 125,
    #[doc = "126 - TCPWM #0, Counter #3"]
    tcpwm_0_interrupts_3 = 126,
    #[doc = "127 - TCPWM #0, Counter #4"]
    tcpwm_0_interrupts_4 = 127,
    #[doc = "128 - TCPWM #0, Counter #5"]
    tcpwm_0_interrupts_5 = 128,
    #[doc = "129 - TCPWM #0, Counter #6"]
    tcpwm_0_interrupts_6 = 129,
    #[doc = "130 - TCPWM #0, Counter #7"]
    tcpwm_0_interrupts_7 = 130,
    #[doc = "131 - TCPWM #1, Counter #0"]
    tcpwm_1_interrupts_0 = 131,
    #[doc = "132 - TCPWM #1, Counter #1"]
    tcpwm_1_interrupts_1 = 132,
    #[doc = "133 - TCPWM #1, Counter #2"]
    tcpwm_1_interrupts_2 = 133,
    #[doc = "134 - TCPWM #1, Counter #3"]
    tcpwm_1_interrupts_3 = 134,
    #[doc = "135 - TCPWM #1, Counter #4"]
    tcpwm_1_interrupts_4 = 135,
    #[doc = "136 - TCPWM #1, Counter #5"]
    tcpwm_1_interrupts_5 = 136,
    #[doc = "137 - TCPWM #1, Counter #6"]
    tcpwm_1_interrupts_6 = 137,
    #[doc = "138 - TCPWM #1, Counter #7"]
    tcpwm_1_interrupts_7 = 138,
    #[doc = "139 - TCPWM #1, Counter #8"]
    tcpwm_1_interrupts_8 = 139,
    #[doc = "140 - TCPWM #1, Counter #9"]
    tcpwm_1_interrupts_9 = 140,
    #[doc = "141 - TCPWM #1, Counter #10"]
    tcpwm_1_interrupts_10 = 141,
    #[doc = "142 - TCPWM #1, Counter #11"]
    tcpwm_1_interrupts_11 = 142,
    #[doc = "143 - TCPWM #1, Counter #12"]
    tcpwm_1_interrupts_12 = 143,
    #[doc = "144 - TCPWM #1, Counter #13"]
    tcpwm_1_interrupts_13 = 144,
    #[doc = "145 - TCPWM #1, Counter #14"]
    tcpwm_1_interrupts_14 = 145,
    #[doc = "146 - TCPWM #1, Counter #15"]
    tcpwm_1_interrupts_15 = 146,
    #[doc = "147 - TCPWM #1, Counter #16"]
    tcpwm_1_interrupts_16 = 147,
    #[doc = "148 - TCPWM #1, Counter #17"]
    tcpwm_1_interrupts_17 = 148,
    #[doc = "149 - TCPWM #1, Counter #18"]
    tcpwm_1_interrupts_18 = 149,
    #[doc = "150 - TCPWM #1, Counter #19"]
    tcpwm_1_interrupts_19 = 150,
    #[doc = "151 - TCPWM #1, Counter #20"]
    tcpwm_1_interrupts_20 = 151,
    #[doc = "152 - TCPWM #1, Counter #21"]
    tcpwm_1_interrupts_21 = 152,
    #[doc = "153 - TCPWM #1, Counter #22"]
    tcpwm_1_interrupts_22 = 153,
    #[doc = "154 - TCPWM #1, Counter #23"]
    tcpwm_1_interrupts_23 = 154,
    #[doc = "155 - SAR ADC interrupt"]
    pass_interrupt_sar = 155,
    #[doc = "156 - I2S0 Audio interrupt"]
    audioss_0_interrupt_i2s = 156,
    #[doc = "157 - PDM0/PCM0 Audio interrupt"]
    audioss_0_interrupt_pdm = 157,
    #[doc = "158 - I2S1 Audio interrupt"]
    audioss_1_interrupt_i2s = 158,
    #[doc = "159 - Energy Profiler interrupt"]
    profile_interrupt = 159,
    #[doc = "160 - Serial Memory Interface interrupt"]
    smif_interrupt = 160,
    #[doc = "161 - USB Interrupt"]
    usb_interrupt_hi = 161,
    #[doc = "162 - USB Interrupt"]
    usb_interrupt_med = 162,
    #[doc = "163 - USB Interrupt"]
    usb_interrupt_lo = 163,
    #[doc = "164 - SDIO wakeup interrupt for mxsdhc"]
    sdhc_0_interrupt_wakeup = 164,
    #[doc = "165 - Consolidated interrupt for mxsdhc for everything else"]
    sdhc_0_interrupt_general = 165,
    #[doc = "166 - EEMC wakeup interrupt for mxsdhc, not used"]
    sdhc_1_interrupt_wakeup = 166,
    #[doc = "167 - Consolidated interrupt for mxsdhc for everything else"]
    sdhc_1_interrupt_general = 167,
}
unsafe impl cortex_m::interrupt::InterruptNumber for Interrupt {
    #[inline(always)]
    fn number(self) -> u16 {
        self as u16
    }
}
#[doc = "Peripheral interconnect"]
pub struct Peri {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Peri {}
impl Peri {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const peri::RegisterBlock = 0x4000_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const peri::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Peri {
    type Target = peri::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Peri {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Peri").finish()
    }
}
#[doc = "Peripheral interconnect"]
pub mod peri;
#[doc = "Peripheral interconnect, master interface"]
pub struct PeriMs {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for PeriMs {}
impl PeriMs {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const peri_ms::RegisterBlock = 0x4001_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const peri_ms::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for PeriMs {
    type Target = peri_ms::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for PeriMs {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("PeriMs").finish()
    }
}
#[doc = "Peripheral interconnect, master interface"]
pub mod peri_ms;
#[doc = "Cryptography component"]
pub struct Crypto {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Crypto {}
impl Crypto {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const crypto::RegisterBlock = 0x4010_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const crypto::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Crypto {
    type Target = crypto::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Crypto {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Crypto").finish()
    }
}
#[doc = "Cryptography component"]
pub mod crypto;
#[doc = "CPU subsystem (CPUSS)"]
pub struct Cpuss {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Cpuss {}
impl Cpuss {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const cpuss::RegisterBlock = 0x4020_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const cpuss::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Cpuss {
    type Target = cpuss::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Cpuss {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Cpuss").finish()
    }
}
#[doc = "CPU subsystem (CPUSS)"]
pub mod cpuss;
#[doc = "Fault structures"]
pub struct Fault {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Fault {}
impl Fault {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const fault::RegisterBlock = 0x4021_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const fault::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Fault {
    type Target = fault::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Fault {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Fault").finish()
    }
}
#[doc = "Fault structures"]
pub mod fault;
#[doc = "IPC"]
pub struct Ipc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Ipc {}
impl Ipc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const ipc::RegisterBlock = 0x4022_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const ipc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Ipc {
    type Target = ipc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Ipc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Ipc").finish()
    }
}
#[doc = "IPC"]
pub mod ipc;
#[doc = "Protection"]
pub struct Prot {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Prot {}
impl Prot {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const prot::RegisterBlock = 0x4023_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const prot::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Prot {
    type Target = prot::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Prot {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Prot").finish()
    }
}
#[doc = "Protection"]
pub mod prot;
#[doc = "Flash controller"]
pub struct Flashc {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Flashc {}
impl Flashc {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const flashc::RegisterBlock = 0x4024_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const flashc::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Flashc {
    type Target = flashc::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Flashc {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Flashc").finish()
    }
}
#[doc = "Flash controller"]
pub mod flashc;
#[doc = "SRSS Core Registers"]
pub struct Srss {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Srss {}
impl Srss {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const srss::RegisterBlock = 0x4026_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const srss::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Srss {
    type Target = srss::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Srss {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Srss").finish()
    }
}
#[doc = "SRSS Core Registers"]
pub mod srss;
#[doc = "SRSS Backup Domain"]
pub struct Backup {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Backup {}
impl Backup {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const backup::RegisterBlock = 0x4027_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const backup::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Backup {
    type Target = backup::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Backup {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Backup").finish()
    }
}
#[doc = "SRSS Backup Domain"]
pub mod backup;
#[doc = "Datawire Controller"]
pub struct Dw0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dw0 {}
impl Dw0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dw0::RegisterBlock = 0x4028_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dw0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dw0 {
    type Target = dw0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dw0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dw0").finish()
    }
}
#[doc = "Datawire Controller"]
pub mod dw0;
#[doc = "Datawire Controller"]
pub struct Dw1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dw1 {}
impl Dw1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dw0::RegisterBlock = 0x4029_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dw0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dw1 {
    type Target = dw0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dw1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dw1").finish()
    }
}
#[doc = "Datawire Controller"]
pub use self::dw0 as dw1;
#[doc = "DMAC"]
pub struct Dmac {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Dmac {}
impl Dmac {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const dmac::RegisterBlock = 0x402a_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const dmac::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Dmac {
    type Target = dmac::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Dmac {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Dmac").finish()
    }
}
#[doc = "DMAC"]
pub mod dmac;
#[doc = "EFUSE MXS40 registers"]
pub struct Efuse {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Efuse {}
impl Efuse {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const efuse::RegisterBlock = 0x402c_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const efuse::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Efuse {
    type Target = efuse::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Efuse {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Efuse").finish()
    }
}
#[doc = "EFUSE MXS40 registers"]
pub mod efuse;
#[doc = "Energy Profiler IP"]
pub struct Profile {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Profile {}
impl Profile {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const profile::RegisterBlock = 0x402d_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const profile::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Profile {
    type Target = profile::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Profile {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Profile").finish()
    }
}
#[doc = "Energy Profiler IP"]
pub mod profile;
#[doc = "High Speed IO Matrix (HSIOM)"]
pub struct Hsiom {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Hsiom {}
impl Hsiom {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const hsiom::RegisterBlock = 0x4030_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const hsiom::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Hsiom {
    type Target = hsiom::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Hsiom {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Hsiom").finish()
    }
}
#[doc = "High Speed IO Matrix (HSIOM)"]
pub mod hsiom;
#[doc = "GPIO port control/configuration"]
pub struct Gpio {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Gpio {}
impl Gpio {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const gpio::RegisterBlock = 0x4031_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const gpio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Gpio {
    type Target = gpio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Gpio {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Gpio").finish()
    }
}
#[doc = "GPIO port control/configuration"]
pub mod gpio;
#[doc = "Programmable IO configuration"]
pub struct Smartio {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Smartio {}
impl Smartio {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smartio::RegisterBlock = 0x4032_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smartio::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Smartio {
    type Target = smartio::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Smartio {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Smartio").finish()
    }
}
#[doc = "Programmable IO configuration"]
pub mod smartio;
#[doc = "Low Power Comparators"]
pub struct Lpcomp {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Lpcomp {}
impl Lpcomp {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lpcomp::RegisterBlock = 0x4035_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lpcomp::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Lpcomp {
    type Target = lpcomp::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Lpcomp {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Lpcomp").finish()
    }
}
#[doc = "Low Power Comparators"]
pub mod lpcomp;
#[doc = "Capsense Controller"]
pub struct Csd0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Csd0 {}
impl Csd0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const csd0::RegisterBlock = 0x4036_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const csd0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Csd0 {
    type Target = csd0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Csd0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Csd0").finish()
    }
}
#[doc = "Capsense Controller"]
pub mod csd0;
#[doc = "Timer/Counter/PWM"]
pub struct Tcpwm0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Tcpwm0 {}
impl Tcpwm0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tcpwm0::RegisterBlock = 0x4038_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tcpwm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Tcpwm0 {
    type Target = tcpwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Tcpwm0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tcpwm0").finish()
    }
}
#[doc = "Timer/Counter/PWM"]
pub mod tcpwm0;
#[doc = "Timer/Counter/PWM"]
pub struct Tcpwm1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Tcpwm1 {}
impl Tcpwm1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const tcpwm0::RegisterBlock = 0x4039_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const tcpwm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Tcpwm1 {
    type Target = tcpwm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Tcpwm1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Tcpwm1").finish()
    }
}
#[doc = "Timer/Counter/PWM"]
pub use self::tcpwm0 as tcpwm1;
#[doc = "LCD Controller Block"]
pub struct Lcd0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Lcd0 {}
impl Lcd0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const lcd0::RegisterBlock = 0x403b_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const lcd0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Lcd0 {
    type Target = lcd0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Lcd0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Lcd0").finish()
    }
}
#[doc = "LCD Controller Block"]
pub mod lcd0;
#[doc = "USB Host and Device Controller"]
pub struct Usbfs0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Usbfs0 {}
impl Usbfs0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const usbfs0::RegisterBlock = 0x403f_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const usbfs0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Usbfs0 {
    type Target = usbfs0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Usbfs0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Usbfs0").finish()
    }
}
#[doc = "USB Host and Device Controller"]
pub mod usbfs0;
#[doc = "Serial Memory Interface"]
pub struct Smif0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Smif0 {}
impl Smif0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const smif0::RegisterBlock = 0x4042_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const smif0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Smif0 {
    type Target = smif0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Smif0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Smif0").finish()
    }
}
#[doc = "Serial Memory Interface"]
pub mod smif0;
#[doc = "SD/eMMC Host Controller"]
pub struct Sdhc0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Sdhc0 {}
impl Sdhc0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sdhc0::RegisterBlock = 0x4046_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sdhc0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Sdhc0 {
    type Target = sdhc0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Sdhc0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sdhc0").finish()
    }
}
#[doc = "SD/eMMC Host Controller"]
pub mod sdhc0;
#[doc = "SD/eMMC Host Controller"]
pub struct Sdhc1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Sdhc1 {}
impl Sdhc1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sdhc0::RegisterBlock = 0x4047_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sdhc0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Sdhc1 {
    type Target = sdhc0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Sdhc1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sdhc1").finish()
    }
}
#[doc = "SD/eMMC Host Controller"]
pub use self::sdhc0 as sdhc1;
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub struct Scb0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Scb0 {}
impl Scb0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scb0::RegisterBlock = 0x4060_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Scb0 {
    type Target = scb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Scb0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Scb0").finish()
    }
}
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub mod scb0;
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub struct Scb1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Scb1 {}
impl Scb1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scb0::RegisterBlock = 0x4061_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Scb1 {
    type Target = scb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Scb1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Scb1").finish()
    }
}
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub use self::scb0 as scb1;
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub struct Scb2 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Scb2 {}
impl Scb2 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scb0::RegisterBlock = 0x4062_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Scb2 {
    type Target = scb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Scb2 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Scb2").finish()
    }
}
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub use self::scb0 as scb2;
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub struct Scb3 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Scb3 {}
impl Scb3 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scb0::RegisterBlock = 0x4063_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Scb3 {
    type Target = scb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Scb3 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Scb3").finish()
    }
}
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub use self::scb0 as scb3;
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub struct Scb4 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Scb4 {}
impl Scb4 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scb0::RegisterBlock = 0x4064_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Scb4 {
    type Target = scb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Scb4 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Scb4").finish()
    }
}
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub use self::scb0 as scb4;
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub struct Scb5 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Scb5 {}
impl Scb5 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scb0::RegisterBlock = 0x4065_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Scb5 {
    type Target = scb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Scb5 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Scb5").finish()
    }
}
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub use self::scb0 as scb5;
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub struct Scb6 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Scb6 {}
impl Scb6 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scb0::RegisterBlock = 0x4066_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Scb6 {
    type Target = scb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Scb6 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Scb6").finish()
    }
}
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub use self::scb0 as scb6;
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub struct Scb7 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Scb7 {}
impl Scb7 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scb0::RegisterBlock = 0x4067_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Scb7 {
    type Target = scb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Scb7 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Scb7").finish()
    }
}
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub use self::scb0 as scb7;
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub struct Scb8 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Scb8 {}
impl Scb8 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scb0::RegisterBlock = 0x4068_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Scb8 {
    type Target = scb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Scb8 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Scb8").finish()
    }
}
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub use self::scb0 as scb8;
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub struct Scb9 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Scb9 {}
impl Scb9 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scb0::RegisterBlock = 0x4069_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Scb9 {
    type Target = scb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Scb9 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Scb9").finish()
    }
}
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub use self::scb0 as scb9;
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub struct Scb10 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Scb10 {}
impl Scb10 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scb0::RegisterBlock = 0x406a_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Scb10 {
    type Target = scb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Scb10 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Scb10").finish()
    }
}
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub use self::scb0 as scb10;
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub struct Scb11 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Scb11 {}
impl Scb11 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scb0::RegisterBlock = 0x406b_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Scb11 {
    type Target = scb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Scb11 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Scb11").finish()
    }
}
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub use self::scb0 as scb11;
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub struct Scb12 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Scb12 {}
impl Scb12 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const scb0::RegisterBlock = 0x406c_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const scb0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Scb12 {
    type Target = scb0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Scb12 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Scb12").finish()
    }
}
#[doc = "Serial Communications Block (SPI/UART/I2C)"]
pub use self::scb0 as scb12;
#[doc = "SAR ADC with Sequencer"]
pub struct Sar {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Sar {}
impl Sar {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const sar::RegisterBlock = 0x409d_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const sar::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Sar {
    type Target = sar::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Sar {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Sar").finish()
    }
}
#[doc = "SAR ADC with Sequencer"]
pub mod sar;
#[doc = "PASS top-level MMIO (DSABv2, INTR)"]
pub struct Pass {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pass {}
impl Pass {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pass::RegisterBlock = 0x409f_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pass::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pass {
    type Target = pass::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pass {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pass").finish()
    }
}
#[doc = "PASS top-level MMIO (DSABv2, INTR)"]
pub mod pass;
#[doc = "PDM registers"]
pub struct Pdm0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for Pdm0 {}
impl Pdm0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const pdm0::RegisterBlock = 0x40a0_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const pdm0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for Pdm0 {
    type Target = pdm0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for Pdm0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("Pdm0").finish()
    }
}
#[doc = "PDM registers"]
pub mod pdm0;
#[doc = "I2S registers"]
pub struct I2s0 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2s0 {}
impl I2s0 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2s0::RegisterBlock = 0x40a1_0000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2s0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2s0 {
    type Target = i2s0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2s0 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2s0").finish()
    }
}
#[doc = "I2S registers"]
pub mod i2s0;
#[doc = "I2S registers"]
pub struct I2s1 {
    _marker: PhantomData<*const ()>,
}
unsafe impl Send for I2s1 {}
impl I2s1 {
    #[doc = r"Pointer to the register block"]
    pub const PTR: *const i2s0::RegisterBlock = 0x40a1_1000 as *const _;
    #[doc = r"Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const i2s0::RegisterBlock {
        Self::PTR
    }
    #[doc = r" Steal an instance of this peripheral"]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
    #[doc = r" that may race with any existing instances, for example by only"]
    #[doc = r" accessing read-only or write-only registers, or by consuming the"]
    #[doc = r" original peripheral and using critical sections to coordinate"]
    #[doc = r" access between multiple new instances."]
    #[doc = r""]
    #[doc = r" Additionally, other software such as HALs may rely on only one"]
    #[doc = r" peripheral instance existing to ensure memory safety; ensure"]
    #[doc = r" no stolen instances are passed to such software."]
    pub unsafe fn steal() -> Self {
        Self {
            _marker: PhantomData,
        }
    }
}
impl Deref for I2s1 {
    type Target = i2s0::RegisterBlock;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
impl core::fmt::Debug for I2s1 {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.debug_struct("I2s1").finish()
    }
}
#[doc = "I2S registers"]
pub use self::i2s0 as i2s1;
#[no_mangle]
static mut DEVICE_PERIPHERALS: bool = false;
#[doc = r" All the peripherals."]
#[allow(non_snake_case)]
pub struct Peripherals {
    #[doc = "PERI"]
    pub peri: Peri,
    #[doc = "PERI_MS"]
    pub peri_ms: PeriMs,
    #[doc = "CRYPTO"]
    pub crypto: Crypto,
    #[doc = "CPUSS"]
    pub cpuss: Cpuss,
    #[doc = "FAULT"]
    pub fault: Fault,
    #[doc = "IPC"]
    pub ipc: Ipc,
    #[doc = "PROT"]
    pub prot: Prot,
    #[doc = "FLASHC"]
    pub flashc: Flashc,
    #[doc = "SRSS"]
    pub srss: Srss,
    #[doc = "BACKUP"]
    pub backup: Backup,
    #[doc = "DW0"]
    pub dw0: Dw0,
    #[doc = "DW1"]
    pub dw1: Dw1,
    #[doc = "DMAC"]
    pub dmac: Dmac,
    #[doc = "EFUSE"]
    pub efuse: Efuse,
    #[doc = "PROFILE"]
    pub profile: Profile,
    #[doc = "HSIOM"]
    pub hsiom: Hsiom,
    #[doc = "GPIO"]
    pub gpio: Gpio,
    #[doc = "SMARTIO"]
    pub smartio: Smartio,
    #[doc = "LPCOMP"]
    pub lpcomp: Lpcomp,
    #[doc = "CSD0"]
    pub csd0: Csd0,
    #[doc = "TCPWM0"]
    pub tcpwm0: Tcpwm0,
    #[doc = "TCPWM1"]
    pub tcpwm1: Tcpwm1,
    #[doc = "LCD0"]
    pub lcd0: Lcd0,
    #[doc = "USBFS0"]
    pub usbfs0: Usbfs0,
    #[doc = "SMIF0"]
    pub smif0: Smif0,
    #[doc = "SDHC0"]
    pub sdhc0: Sdhc0,
    #[doc = "SDHC1"]
    pub sdhc1: Sdhc1,
    #[doc = "SCB0"]
    pub scb0: Scb0,
    #[doc = "SCB1"]
    pub scb1: Scb1,
    #[doc = "SCB2"]
    pub scb2: Scb2,
    #[doc = "SCB3"]
    pub scb3: Scb3,
    #[doc = "SCB4"]
    pub scb4: Scb4,
    #[doc = "SCB5"]
    pub scb5: Scb5,
    #[doc = "SCB6"]
    pub scb6: Scb6,
    #[doc = "SCB7"]
    pub scb7: Scb7,
    #[doc = "SCB8"]
    pub scb8: Scb8,
    #[doc = "SCB9"]
    pub scb9: Scb9,
    #[doc = "SCB10"]
    pub scb10: Scb10,
    #[doc = "SCB11"]
    pub scb11: Scb11,
    #[doc = "SCB12"]
    pub scb12: Scb12,
    #[doc = "SAR"]
    pub sar: Sar,
    #[doc = "PASS"]
    pub pass: Pass,
    #[doc = "PDM0"]
    pub pdm0: Pdm0,
    #[doc = "I2S0"]
    pub i2s0: I2s0,
    #[doc = "I2S1"]
    pub i2s1: I2s1,
}
impl Peripherals {
    #[doc = r" Returns all the peripherals *once*."]
    #[cfg(feature = "critical-section")]
    #[inline]
    pub fn take() -> Option<Self> {
        critical_section::with(|_| {
            if unsafe { DEVICE_PERIPHERALS } {
                return None;
            }
            Some(unsafe { Peripherals::steal() })
        })
    }
    #[doc = r" Unchecked version of `Peripherals::take`."]
    #[doc = r""]
    #[doc = r" # Safety"]
    #[doc = r""]
    #[doc = r" Each of the returned peripherals must be used at most once."]
    #[inline]
    pub unsafe fn steal() -> Self {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            peri: Peri::steal(),
            peri_ms: PeriMs::steal(),
            crypto: Crypto::steal(),
            cpuss: Cpuss::steal(),
            fault: Fault::steal(),
            ipc: Ipc::steal(),
            prot: Prot::steal(),
            flashc: Flashc::steal(),
            srss: Srss::steal(),
            backup: Backup::steal(),
            dw0: Dw0::steal(),
            dw1: Dw1::steal(),
            dmac: Dmac::steal(),
            efuse: Efuse::steal(),
            profile: Profile::steal(),
            hsiom: Hsiom::steal(),
            gpio: Gpio::steal(),
            smartio: Smartio::steal(),
            lpcomp: Lpcomp::steal(),
            csd0: Csd0::steal(),
            tcpwm0: Tcpwm0::steal(),
            tcpwm1: Tcpwm1::steal(),
            lcd0: Lcd0::steal(),
            usbfs0: Usbfs0::steal(),
            smif0: Smif0::steal(),
            sdhc0: Sdhc0::steal(),
            sdhc1: Sdhc1::steal(),
            scb0: Scb0::steal(),
            scb1: Scb1::steal(),
            scb2: Scb2::steal(),
            scb3: Scb3::steal(),
            scb4: Scb4::steal(),
            scb5: Scb5::steal(),
            scb6: Scb6::steal(),
            scb7: Scb7::steal(),
            scb8: Scb8::steal(),
            scb9: Scb9::steal(),
            scb10: Scb10::steal(),
            scb11: Scb11::steal(),
            scb12: Scb12::steal(),
            sar: Sar::steal(),
            pass: Pass::steal(),
            pdm0: Pdm0::steal(),
            i2s0: I2s0::steal(),
            i2s1: I2s1::steal(),
        }
    }
}
